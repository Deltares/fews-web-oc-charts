<!DOCTYPE html>
<html lang="nl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Zoom Options</title>
  <style>

    html, body {
      height: 100%;
      margin: 0px;
      font-size: 16px;
      font-family: sans-serif;
    }

    .wbcharts svg {
      overflow: visible;
    }

    body {
      background-color: rgb(44, 44, 44);
      font: 14px sans-serif;
      margin: 20px;
    }

    text {
      fill: white;
    }

    title {
      stroke: black;
    }

    .axis-canvas {
      fill:rgb(89, 89, 89);
    }

    .chart-container {
      position: relative;
      display: block;
      width: 100%;
      height: 100vh;
      max-height: 414px;
      fill: white;
    }

    .chart-legend {
      display: block;
      fill: white;
    }

    #control-line {
      fill: none;
      stroke: red;
      stroke-dasharray: 4, 2;
      stroke-width: 2px;
    }

    #median-line {
      fill: none;
      stroke: white;
      stroke-width: 2px;
    }

    #perc50 {
      fill: skyblue;
      stroke: skyblue;
    }

    #perc90 {
      fill: deepskyblue;
      stroke: deepskyblue;
    }

  </style>
  <script src="https://d3js.org/d3.v7.js"></script>
  <script src="https://d3js.org/d3-selection-multi.v1.min.js"></script>
  <link rel="stylesheet" href="../dist/wb-charts-dark.css">
</head>
<body>
  <!-- Waterlevel -->
  <div>
    <div id="chart-waterlevel1" class="chart-container"></div>
    <div id="legend-waterlevel1" class="chart-legend"></div>
    <button onclick="restoreZoom(plot1)">Restore zoom</button>
    <button onclick="zoomToFullExtent(plot1)">Zoom to full extent</button>
    <button onclick="zoomToYDefault(plot1, defaultYDomain1)">Zoom Y-axis to defaultDomain</button>
    <button onclick="zoomToDomain(plot1)">Zoom Y-axis to [-350, 480]</button>
    <div id="chart-waterlevel2" class="chart-container"></div>
    <div id="legend-waterlevel2" class="chart-legend"></div>
    <button onclick="restoreZoom(plot2)">Restore zoom</button>
    <button onclick="zoomToFullExtent(plot2)">Zoom to full extent</button>
    <button onclick="zoomToYDefault(plot2, defaultYDomain2)">Zoom Y-axis to defaultDomain</button>
    <button onclick="zoomToDomain(plot2)">Zoom Y-axis to [-350, 480]</button>
    <div id="chart-waterlevel3" class="chart-container"></div>
    <div id="legend-waterlevel3" class="chart-legend"></div>
    <button onclick="restoreZoom(plot3)">Restore zoom</button>
    <button onclick="zoomToFullExtent(plot3)">Zoom to full extent</button>
    <button onclick="zoomToYDefault(plot3, defaultYDomain3)">Zoom Y-axis to defaultDomain</button>
    <button onclick="zoomToDomain(plot3)">Zoom Y-axis to [-350, 480]</button>
    <div id="chart-waterlevel4" class="chart-container"></div>
    <div id="legend-waterlevel4" class="chart-legend"></div>
    <button onclick="restoreZoom(plot4)">Restore zoom</button>
    <button onclick="zoomToFullExtent(plot4)">Zoom to full extent</button>
    <button onclick="zoomToYDefault(plot4, defaultYDomain4)">Zoom Y-axis to defaultDomain</button>
    <button onclick="zoomToDomain(plot4)">Zoom Y-axis to [-350, 480]</button>
  </div>

  <script src="../dist/wb-charts.umd.js"></script>
  <script type="text/javascript">

    const defaultYDomain1 = [-100, 100]
    const defaultYDomain2 = [50, 150]
    const defaultYDomain3 = [50, 150]
    const defaultYDomain4 = [50, 150]
    const xAxisOptions = {
      type: wbCharts.AxisType.time,
      label: 'datum',
      position: wbCharts.AxisPosition.Bottom,
      showGrid: false,
    }
    const yAxisOptions = {
      position: wbCharts.AxisPosition.Left,
      label: 'Waterstand',
      unit: 'cm',
      nice: true,
      showGrid: true,
    }
    const marginAxisOptions = {
      left: 100,
      right: 100
    }
    const axisOptions1 = {
      x: [xAxisOptions],
      y: [{...yAxisOptions, ...{defaultDomain: defaultYDomain1, resetZoom: 'toggle'}}],
      margin: marginAxisOptions
    }
    const axisOptions2 = {
      x: [xAxisOptions],
      y: [{...yAxisOptions, ...{defaultDomain: defaultYDomain2}}],
      margin: marginAxisOptions
    }
    const axisOptions3 = {
      x: [xAxisOptions],
      y: [{...yAxisOptions, ...{includeZero: true, defaultDomain: defaultYDomain3, resetZoom: 'full'}}],
      margin: marginAxisOptions
    }
    const axisOptions4 = {
      x: [xAxisOptions],
      y: [{...yAxisOptions, ...{includeZero: true, defaultDomain: defaultYDomain4}}],
      margin: marginAxisOptions
    }

    const chartOptions = {
      x: {
        key: "time",
        axisIndex: 0
      },
      y: {
        key: "value",
        axisIndex: 0
      }
    }

    const chartOptionLevels = {
      x: {
        key: "date",
        axisIndex: 0
      },
      y: {
        key: "value",
        axisIndex: 0
      }
    }

    const legendLabels = [{
        selector: 'median',
        label: 'Middelste (P50)'
      },
      {
        selector: 'control',
        label: 'Controle'
      },
      {
        selector: 'percent90',
        label: '90% interval'
      },
      {
        selector: 'percent50',
        label: '50% interval'
      },
    ]

    var container1 = document.getElementById("chart-waterlevel1");
    var axis1 = new wbCharts.CartesianAxes(container1, null, null, axisOptions1)
    var legend1 = new wbCharts.Legend(legendLabels, document.getElementById("legend-waterlevel1"));

    var container2 = document.getElementById("chart-waterlevel2");
    var axis2 = new wbCharts.CartesianAxes(container2, null, null, axisOptions2)
    var legend2 = new wbCharts.Legend(legendLabels, document.getElementById("legend-waterlevel2"));

    var container3 = document.getElementById("chart-waterlevel3");
    var axis3 = new wbCharts.CartesianAxes(container3, null, null, axisOptions3)
    var legend3 = new wbCharts.Legend(legendLabels, document.getElementById("legend-waterlevel3"));

    var container4 = document.getElementById("chart-waterlevel4");
    var axis4 = new wbCharts.CartesianAxes(container4, null, null, axisOptions4)
    var legend4 = new wbCharts.Legend([legendLabels[2], legendLabels[3]], document.getElementById("legend-waterlevel4"));

    function getRoundedDate(minutes, d = new Date()) {
      let ms = 1000 * 60 * minutes; // convert minutes to ms
      let roundedDate = new Date(Math.round(d.getTime() / ms) * ms);
      return roundedDate
    }

    percentile = function (p, data) {
      var points = data;
      points.sort(function (a, b) {
        return a - b
      });
      if (Array.isArray(p)) {
        var result = [];
        for (i = 0; i < p.length; ++i) {
          var x = p[i] * (points.length + 1);
          var x1 = Math.floor(x);
          var frac = x - x1;
          result.push(points[x1 - 1] + frac * (points[x1] - points[x1 - 1]));
        }
        return result;
      } else {
        var x = p * (points.length + 1);
        var x1 = Math.floor(x);
        var frac = x - x1;
        return points[x1 - 1] + frac * (points[x1] - points[x1 - 1]);
      }
    };

    var refDate = getRoundedDate( 10, new Date());

    var escalationLevels = [{
        id: 'laag',
        events: [],
        levelStart: -220,
        levelEnd: -150,
        color: 'rgba(205, 133, 63,.5)',
        c: '<'
      },
      {
        id: 'verhoogd',
        events: [],
        levelStart: 80,
        levelEnd: 100,
        color: 'rgba(255, 215, 0,.5)',
        c: '>'
      },
      {
        id: 'hoog',
        events: [],
        levelStart: 120,
        levelEnd: 110,
        color: 'rgba(255, 150, 0,.5)',
        c: '>'
      },
      {
        id: 'extreem',
        events: [],
        levelStart: 200,
        levelEnd: 250,
        color: 'rgba(255, 0, 0,.5)',
        c: '>'
      }
    ]

    plot1 = {
      axis: axis1,
      escalations: escalationLevels,
      positiveData: false,
      onlyRanges: false,
    }
    axis1.accept(legend1);

    plot2 = {
      axis: axis2,
      escalations: escalationLevels,
      positiveData: true,
      onlyRanges: false,
    }
    axis2.accept(legend2);

    plot3 = {
      axis: axis3,
      escalations: escalationLevels,
      positiveData: true,
      onlyRanges: false,
    }
    axis3.accept(legend3);

    plot4 = {
      axis: axis4,
      escalations: escalationLevels,
      positiveData: true,
      onlyRanges: true,
    }
    axis4.accept(legend4);

    function dataload(plot) {
      d3.json("ensemble.json").then(function (data) {
        // load data
        var nEnsemble = data.values[0].length;
        var members = Array(nEnsemble);
        var percentiles = [
          [],
          [],
          []
        ];
        const offset = plot.positiveData ? 150 : 0;

        for (s = 0; s < nEnsemble; s++) {
          members[s] = Array();
        }
        var medianTime = (data.times[0] + data.times[data.times.length - 1]) / 2;
        plot.escalations.forEach( function (el, i) {
          el.events = []
        })

        data.times.forEach(function (time, index) {
          var dateTime = new Date((time - medianTime) * 1000 + refDate.getTime());
          for (i = 0; i < nEnsemble; i++) {
            members[i].push({
              [chartOptions.x.key]: dateTime,
              [chartOptions.y.key]: data.values[index][i] + offset
            })
          }
          var points = data.values[index]
          if (!plot.onlyRanges) {
            percentiles[0].push({
              [chartOptions.x.key]: dateTime,
              [chartOptions.y.key]: percentile(.5, points) + offset
            });
          }
          const perc50 = percentile([0.25, 0.75], points)
          percentiles[1].push({
            [chartOptions.x.key]: dateTime,
            [chartOptions.y.key]: [perc50[0] + offset, perc50[1] + offset]
          });
          const perc90 = percentile([0.05, 0.95], points)
          percentiles[2].push({
            [chartOptions.x.key]: dateTime,
            [chartOptions.y.key]: [perc90[0] + offset, perc90[1] + offset]
          });

          plot.escalations.forEach( function (el, i) {
            let val = el.levelStart
            if (index > data.times.length / 2 ) {
              val = el.levelEnd
            }
            el.events.push({
              date: dateTime,
              value: val,
            })
          });
        })

        // Plot
        var mouseOver = new wbCharts.MouseOver(['control', 'median', 'percent90']);
        var zoom = new wbCharts.ZoomHandler();

        if (!plot.onlyRanges) {
          var plotMedian = new wbCharts.ChartLine(percentiles[0], {});
          var plotControl = new wbCharts.ChartLine(members[0], {});
        }
        var plotPercentile50 = new wbCharts.ChartArea(percentiles[1], {});
        var plotPercentile90 = new wbCharts.ChartArea(percentiles[2], {});

        plotPercentile90.addTo(plot.axis, chartOptions, 'percent90', '#perc90');
        plotPercentile50.addTo(plot.axis, chartOptions, 'percent50', '#perc50');
        if (!plot.onlyRanges) {
          plotControl.addTo(plot.axis, chartOptions, 'control', '#control-line');
          plotMedian.addTo(plot.axis, chartOptions, 'median', '#median-line');
        }

        var escalationsVisitor = new wbCharts.WarningLevels(plot.escalations);
        plot.axis.accept(escalationsVisitor);
        plot.escalations.forEach( function (el, i) {
          const escLevel = new wbCharts.ChartLine(el.events, {curve: 'stepAfter', y: { includeInAutoScale: false }});
          escLevel.addTo(plot.axis, chartOptionLevels, el.id, {fill: 'none', stroke: el.color, 'stroke-width': '2px', 'stroke-dasharray': '4, 2'})
        })

        if (!plot.onlyRanges) {
          plot.axis.accept(mouseOver);
        }
        plot.axis.accept(zoom);
        plot.axis.redraw({ x: { autoScale: true }, y: { autoScale: true, nice: true} });

        plot.axis.zoom();
      });
    }

    window.setTimeout(dataload(plot1), 500);
    window.setTimeout(dataload(plot2), 500);
    window.setTimeout(dataload(plot3), 500);
    window.setTimeout(dataload(plot4), 500);


    function restoreZoom(plot) {
      plot.axis.redraw({ x: { autoScale: true }, y: { autoScale: true, nice: true } });
    }

    function zoomToFullExtent(plot) {
      plot.axis.redraw({ x: { autoScale: true }, y: { fullExtent: true, nice: true } });
    }

    function zoomToYDefault(plot, defaultYDomain) {
      plot.axis.redraw({ x: { autoScale: true }, y: { domain: defaultYDomain, nice: true } });
    }

    function zoomToDomain(plot) {
      plot.axis.redraw({ x: { autoScale: true }, y: { domain: [-350, 480], nice: false } });
    }
  </script>

</body>
</html>

