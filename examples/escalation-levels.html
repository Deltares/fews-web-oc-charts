<!DOCTYPE html>
<html lang="nl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Escalation Levels</title>
  <style>

    html, body {
      height: 100%;
      margin: 0px;
      font-size: 16px;
      font-family: sans-serif;
    }

    .wbcharts svg {
      overflow: visible;
    }

    body {
      background-color: rgb(44, 44, 44);
      font: 14px sans-serif;
      margin: 20px;
    }

    text {
      fill: white;
    }

    title {
      stroke: black;
    }

    .axis-canvas {
      fill:rgb(89, 89, 89);
    }

    .chart-container {
      position: relative;
      display: block;
      width: 100%;
      height: 100vh;
      max-height: 414px;
      fill: white;
    }

    .chart-legend {
      display: block;
      fill: white;
    }

    #control-line {
      fill: none;
      stroke: red;
      stroke-dasharray: 4, 2;
      stroke-width: 2px;
    }

    #median-line {
      fill: none;
      stroke: white;
      stroke-width: 2px;
    }

    #perc50 {
      fill: skyblue;
      stroke: skyblue;
    }

    #perc90 {
      fill: deepskyblue;
      stroke: deepskyblue;
    }

  </style>
  <script src="https://d3js.org/d3.v7.js"></script>
  <script src="https://d3js.org/d3-selection-multi.v1.min.js"></script>
  <link rel="stylesheet" href="../dist/wb-charts-dark.css">
</head>

<body>
  <!-- Waterlevel -->
  <div>
    <div id="chart-waterlevel-1" class="chart-container"></div>
    <div id="legend-waterlevel-1" class="chart-legend"></div>
  </div>
  <!-- Waterlevel 2 -->
  <div>
    <div id="chart-waterlevel-2" class="chart-container"></div>
    <div id="legend-waterlevel-2" class="chart-legend"></div>
  </div>

  <script src="../dist/wb-charts.umd.js"></script>
  <script type="text/javascript">
    const axisOptions = {
      x: [{
        type: wbCharts.AxisType.time,
        label: 'datum',
        position: wbCharts.AxisPosition.Bottom,
        showGrid: false,
      }, ],
      y: [{
        position: wbCharts.AxisPosition.Left,
        showGrid: true,
        nice: true,
        includeZero: true,
        label: 'Waterstand',
        unit: 'cm',
      }, ],
      margin: {
        left: 100,
        right: 100
      }
    }

    const chartOptions = {
      x: {
        key: "x",
        axisIndex: 0
      },
      y: {
        key: "y",
        axisIndex: 0
      }
    }

    const legendLabels = [{
        selector: 'median',
        label: 'Middelste (P50)'
      },
      {
        selector: 'control',
        label: 'Controle'
      },
      {
        selector: 'percent90',
        label: '90% interval'
      },
      {
        selector: 'percent50',
        label: '50% interval'
      },
    ]

    var container1 = document.getElementById("chart-waterlevel-1");
    var axis1 = new wbCharts.CartesianAxis(container1, null, null, axisOptions)
    var legend1 = new wbCharts.Legend(legendLabels, document.getElementById("legend-waterlevel-1"));

    var container2 = document.getElementById("chart-waterlevel-2");
    var axis2 = new wbCharts.CartesianAxis(container2, null, null, axisOptions)
    var legend2 = new wbCharts.Legend(legendLabels, document.getElementById("legend-waterlevel-2"));


    function getRoundedDate(minutes, d = new Date()) {
        let ms = 1000 * 60 * minutes; // convert minutes to ms
        let roundedDate = new Date(Math.round(d.getTime() / ms) * ms);
        return roundedDate
    }

    percentile = function (p, data) {
      var points = data;
      points.sort(function (a, b) {
        return a - b
      });
      if (Array.isArray(p)) {
        var result = [];
        for (i = 0; i < p.length; ++i) {
          var x = p[i] * (points.length + 1);
          var x1 = Math.floor(x);
          var frac = x - x1;
          result.push(points[x1 - 1] + frac * (points[x1] - points[x1 - 1]));
        }
        return result;
      } else {
        var x = p * (points.length + 1);
        var x1 = Math.floor(x);
        var frac = x - x1;
        return points[x1 - 1] + frac * (points[x1] - points[x1 - 1]);
      }
    };

    var refDate = getRoundedDate( 10, new Date());

    var escalationLevels1 = [{
        id: 'laag',
        val: -100,
        color: 'rgba(205, 133, 63,.5)',
        c: '<'
      },
      {
        id: 'verhoogd',
        val: 100,
        color: 'rgba(255, 215, 0,.5)',
        c: '>'
      },
      {
        id: 'hoog',
        val: 110,
        color: 'rgba(255, 150, 0,.5)',
        c: '>'
      },
      {
        id: 'extreem',
        val: 140,
        color: 'rgba(255, 0, 0,.5)',
        c: '>'
      }
    ]

    var escalationLevels2 = [{
        id: 'bruin',
        val: -100,
        color: 'rgba(205, 133, 63,.5)',
        c: '<'
      },
      {
        id: 'groen',
        val: 10,
        color: 'rgba(164,237,18,.5)',
        c: '<'
      },
      {
        id: 'geel',
        val: 50,
        color: 'rgba(255, 215, 0,.5)',
        c: '>'
      },
      {
        id: 'oranje',
        val: 160,
        color: 'rgba(255, 150, 0,.5)',
        c: '>'
      },
      {
        id: 'rood',
        val: 200,
        color: 'rgba(255, 0, 0,.5)',
        c: '>'
      }
    ]

    var escalationsVisitor1 = new wbCharts.WarningLevels(escalationLevels1);
    var escalationsVisitor2 = new wbCharts.WarningLevels(escalationLevels2);

    plot1 = {
      axis: axis1,
      escalations: escalationsVisitor1
    }
    plot2 = {
      axis: axis2,
      escalations: escalationsVisitor2
    }

    var zoom = new wbCharts.ZoomHandler();

    axis1.accept(legend1);
    axis2.accept(legend2);

    function dataload(plot) {
      d3.json("ensemble.json").then(function (data) {
        // load data
        var nEnsemble = data.values[0].length;
        var members = Array(nEnsemble);
        var percentiles = [
          [],
          [],
          []
        ];

        for (s = 0; s < nEnsemble; s++) {
          members[s] = Array();
        }
        var medianTime = (data.times[0] + data.times[data.times.length - 1]) / 2;

        data.times.forEach(function (time, index) {
          var dateTime = new Date((time - medianTime) * 1000 + refDate.getTime());
          for (i = 0; i < nEnsemble; i++) {
            members[i].push({
              x: dateTime,
              y: data.values[index][i]
            })
          }
          var points = data.values[index]
          percentiles[0].push({
            x: dateTime,
            y: percentile(.5, points)
          });
          percentiles[1].push({
            x: dateTime,
            y: percentile([0.25, 0.75], points)
          });
          percentiles[2].push({
            x: dateTime,
            y: percentile([0.05, 0.95], points)
          });
        })

        // Plot
        var mouseOver = new wbCharts.MouseOver(['control', 'median', 'percent90']);

        var plotMedian = new wbCharts.ChartLine(percentiles[0], {});
        var plotControl = new wbCharts.ChartLine(members[0], {});

        var plotPercentile50 = new wbCharts.ChartArea(percentiles[1], {});
        var plotPercentile90 = new wbCharts.ChartArea(percentiles[2], {});

        plotPercentile90.addTo(plot.axis, chartOptions, 'percent90', '#perc90');
        plotPercentile50.addTo(plot.axis, chartOptions, 'percent50', '#perc50');
        plotControl.addTo(plot.axis, chartOptions, 'control', '#control-line');
        plotMedian.addTo(plot.axis, chartOptions, 'median', '#median-line');
        plot.axis.accept(plot.escalations);
        plot.axis.redraw({ x: { autoScale: true }, y: { autoScale: true } });
        plot.axis.zoom();
        plot.axis.accept(mouseOver);
        plot.axis.accept(zoom);
      });
    }
    for (const plot of [plot1, plot2]) {
      window.setTimeout(dataload(plot), 500);
    }


  </script>

</body>
</html>
